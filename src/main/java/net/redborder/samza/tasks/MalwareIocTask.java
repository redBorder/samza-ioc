package net.redborder.samza.tasks;

import net.redborder.samza.ioc.IOC;
import net.redborder.samza.rules.RulesManager;
import net.redborder.samza.util.AerospikeStore;
import org.apache.samza.config.Config;
import org.apache.samza.storage.kv.Entry;
import org.apache.samza.storage.kv.KeyValueIterator;
import org.apache.samza.storage.kv.KeyValueStore;
import org.apache.samza.system.IncomingMessageEnvelope;
import org.apache.samza.system.OutgoingMessageEnvelope;
import org.apache.samza.system.SystemStream;
import org.apache.samza.task.*;
import org.codehaus.jackson.map.ObjectMapper;

import java.util.*;

public class MalwareIocTask implements StreamTask, InitableTask, WindowableTask {
    private static final SystemStream OUTPUT_STREAM = new SystemStream("kafka", "rb_ioc_post");
    AerospikeStore aerospikeStore;
    public KeyValueStore<String, List<String>> iocStores;
    public List<IOC> iocs = new LinkedList<>();
    public RulesManager rulesManager;

    @Override
    public void init(Config config, TaskContext taskContext) throws Exception {
        this.aerospikeStore = new AerospikeStore(config);
        this.iocStores = (KeyValueStore<String, List<String>>) taskContext.getStore("ioc");
        this.rulesManager = new RulesManager(config, taskContext);

        ObjectMapper objectMapper = new ObjectMapper();
        String iocJson = config.get("net.redborder.ioc", "[]");
        List<Map<String, Object>> iocMaps = objectMapper.readValue(iocJson, List.class);

        for (Map<String, Object> iocMap : iocMaps) {
            String uuid = String.valueOf(iocMap.get("uuid"));
            List<String> rules = (List<String>) iocMap.get("rules");
            iocs.add(new IOC(uuid, new HashSet(rules)));
        }
    }

    @Override
    public void process(IncomingMessageEnvelope messageEnvelope, MessageCollector collector,
                        TaskCoordinator taskCoordinator) throws Exception {
        String endpointUUID = (String) messageEnvelope.getKey();
        Map<String, Object> message = (Map<String, Object>) messageEnvelope.getMessage();

        rulesManager.verify(endpointUUID, message);
    }

    @Override
    public void window(MessageCollector collector, TaskCoordinator taskCoordinator) throws Exception {
        KeyValueIterator<String, List<String>> endpoints = rulesManager.getRules();

        while (endpoints.hasNext()) {
            Entry<String, List<String>> endpoint = endpoints.next();
            List<String> enabledIOCs = iocStores.get(endpoint.getKey());

            if (enabledIOCs == null) {
                enabledIOCs = new ArrayList<>();
            }


            Set<String> enabledRules = new HashSet<>();

            for (String rule : endpoint.getValue()) {
                enabledRules.add(rule.split(":")[0]);
            }

            for (IOC ioc : iocs) {
                Map<String, Object> toDruid = new HashMap<>();
                toDruid.put("timestamp", System.currentTimeMillis() / 1000);
                toDruid.put("endpoint_uuid", endpoint.getKey());
                toDruid.put("ioc", ioc.iocUuid);
                if (ioc.verify(enabledRules)) {
                    if (!enabledIOCs.contains(ioc.iocUuid)) {
                        enabledIOCs.add(ioc.iocUuid);
                        toDruid.put("action", "up");
                        collector.send(new OutgoingMessageEnvelope(OUTPUT_STREAM, toDruid));
                    }
                } else {
                    if (enabledIOCs.contains(ioc.iocUuid)) {
                        enabledIOCs.remove(ioc.iocUuid);
                        toDruid.put("action", "down");
                        collector.send(new OutgoingMessageEnvelope(OUTPUT_STREAM, toDruid));
                    }
                }

                iocStores.put(endpoint.getKey(), enabledIOCs);
            }

            aerospikeStore.updateIOC(endpoint.getKey(), enabledIOCs);
        }
    }
}
